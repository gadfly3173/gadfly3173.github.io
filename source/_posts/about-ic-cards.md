---
title: 关于NFC和IC智能卡的一二三
layout: post
date: 2019-09-29 22:37:35
categories: NFC
tags:
- IC卡
- 单片机
- 近场通信
permalink:
visible:
---
<small>*本文中提到的`卡片`，若非特别注明，均为非接触式卡片，不再另外声明。*</small>

### 概述
首先分析NFC和我们身边的IC卡之前，我们需要先介绍一些基本的概念：
>近场通信技术（Near-field communication，NFC）由非接触式射频识别（RFID）演变而来，由飞利浦半导体（现恩智浦半导体）、诺基亚和索尼共同于2004年研制开发，其基础是RFID及互连技术。近场通信是一种短距高频的无线电技术，在13.56MHz频率运行于20厘米距离内。其传输速度有106 Kbit/秒、212 Kbit/秒或者424 Kbit/秒三种。当前近场通信已通过成为ISO/IEC IS 18092国际标准、EMCA-340标准与ETSI TS 102 190标准。NFC采用主动和被动两种读取模式。
>
>每一个完整的NFC设备可以用三种模式工作：
>- 卡模拟模式（Card emulation mode）：这个模式其实就是相当于一张采用RFID技术的IC卡。可以替代现在大量的IC卡（包括信用卡）场合商场刷卡、IPASS、门禁管制、车票、门票等等。此种方式下，有一个极大的优点，那就是卡片通过非接触读卡器的RF域来供电，即便是寄主设备（如手机）没电也可以工作。NFC设备若要进行卡片模拟（Card Emulation）相关应用，则必须内置安全组件（Security Element, SE）之NFC芯片或通过软件实现主机卡模拟(Host Card Emulation，HCE)。
>- 读卡器模式（Reader/Writer mode）：作为非接触读卡器使用，比如从海报或者展览信息电子标签上读取相关信息。
>- 点对点模式（P2P mode）：这个模式和红外线差不多，可用于数据交换，只是传输距离较短，传输创建速度较快，传输速度也快些，功耗低（蓝牙也类似）。将两个具备NFC功能的设备链接，能实现数据点对点传输，如下载音乐、交换图片或者同步设备地址薄。因此通过NFC，多个设备如数字相机、PDA、计算机和手机之间都可以交换资料或者服务。
>
><small>*摘自：[zh.wikipedia.org/wiki/近場通訊](https://zh.wikipedia.org/wiki/近場通訊)*</small>

这么大一段话概括一下的话，大致意思是：NFC是一种使得数据可以在几厘米的范围内进行传输的技术，我们身边常见的大陆二代身份证、电子护照、公交卡等都属于这种技术的具体应用。
NFC在我们身边的具体应用场景有很多，有时我们会将其错误地认为是其他技术的实现。比如大家常说银行卡、公交卡等“消磁了”，但事实上现在这些卡片已经不再是使用磁条等传统的磁性物质记录数据，而是支持非接触式射频识别（RFID）的电子芯片。他们出现失效的情况一般也不是因为某些磁性物质损坏了，而是其中的线圈或者芯片遭受了物理损伤，比如卡片被弯折等，或者是其他使用类似技术的读写卡器等破坏了其中存储的数据导致无法正常读取。

传统的RFID技术我这里就不多做解释，将其理解为某种特殊的无线电通信技术即可。NFC只是限于13.56MHz的频段，而RFID的频段有低频（125KHz到135KHz），高频（13.56MHz）和超高频（860MHz到960MHz）之间。NFC工作有效距离小于10cm，所以具有很高的安全性，RFID工作有效距离从几米到几十米都有。RFID标准较多，统一较为复杂（估计是没可能统一的了），只能在特殊行业有特殊需求下，采用相应的技术标准。
传统RFID最常见的应用是图书馆的书籍，不是特别寒酸的图书馆的藏书上都会贴有特殊的标签，这种标签可以在一个比较大的范围内被读取，这样就可以实现简便的自助化的图书借阅管理，读者将书放在特定的区域就可以被读取到借阅了哪些书，而不像以前的图书馆需要管理员将扉页上的藏书条形码进行人工扫描，大大提升了效率。许多物流运输也通过类似的方法来管理运输箱，通过机器就可以远程分拣，也方便管理。NFC就是在这样的技术上发展而来，更适合一般日常生活的使用。

### 生活中的各种可以刷的卡都是NFC么
答案显然是否定的。要看一张卡是不是支持NFC技术的卡有以下几种方法：
1. 用一张支持NFC的安卓手机刷一下
虽然手机厂商在宣传NFC时有很多会说什么“全功能NFC”之类的，但是那只是针对之前wikipedia上提到的“卡模拟模式”说的，在读取NFC卡片这件事情上，除了iPhone以外，大家都没有特别大的区别。这边推荐一个名为“MIFARE 经典工具”的app，在GitHub和Google Play上都可以下载：
- Play： [de.syss.MifareClassicTool](https://play.google.com/store/apps/details?id=de.syss.MifareClassicTool)
- GitHub： [ikarus23/MifareClassicTool](https://github.com/ikarus23/MifareClassicTool)
- F-Droid：[de.syss.MifareClassicTool](https://f-droid.org/packages/de.syss.MifareClassicTool/)
- *可用的国内镜像我之后再补充*
使用这个app可以读取到NFC卡片中的部分信息，不过这个app并非支持所有的NFC卡片，只支持MIFARE系列及相似技术的模拟卡（这个问题稍后再说）。首先这个app能识别的肯定是NFC卡片，如果app没有反应，但是手机中的其他应用，比如QQ、微信、金融类app等对其有反应，那么这张卡片也是NFC卡片的一种。
2. 如果卡片本身不是特别厚，并且是一般的长方形卡片，则可以用手电筒等能在较小的范围内聚集大量光源的设备照亮这张卡。如果发现里面的小芯片在卡片的某一边，外面有一圈贴近卡片边缘的线圈，形如下图，那么这一般也是NFC技术的卡片。
![](/images/posts/2019/09/ic_coil.png)
3. 如果卡片上没有10+8位的数字，也没有8-10位的数字，并且没有标注HID之类的字样，那么这张卡一般也是一种NFC卡片。

那么如果我们平时使用的非接触式卡片不是NFC的卡片的话，那么又是什么卡片呢？最常见的就是ID卡了。
>ID卡全称为身份识别卡（Identification Card），是一种不可写入的感应卡，含固定的编号。ID卡与磁卡一样，都仅仅使用了“卡的号码”而已，卡内除了卡号外，无任何加密存储功能，其“卡号”是公开、裸露的。ISO标准ID卡的规格为：85.5x54x0.80±0.04mm（高/宽/厚），市场上也存在一些厚、薄卡或异型卡。

最常见的异型卡就是下图右边这种，统称为钥匙扣：
![](/images/posts/2019/09/id_card.png)
![](/images/posts/2019/09/id_coil.png)
而NFC卡片则一般统称为IC卡：
>智能卡（英语：Smart card或IC Card），又称智慧卡、聪明卡、集成电路卡及IC卡。是指粘贴或嵌有集成电路芯片的一种便携式卡片塑胶。卡片包含了微处理器、I/O接口及存储器，提供了数据的运算、访问控制及存储功能，卡片的大小、接点定义当前是由ISO规范统一，主要规范在ISO7810中。常见的有电话IC卡、身份IC卡，以及一些交通票证和存储卡。
>
><small>*摘自：[zh.wikipedia.org/wiki/智慧卡](https://zh.wikipedia.org/wiki/智慧卡)*</small>

不过IC卡不是只有非接触式的，手机使用的sim卡、银行卡上那个裸露的金属芯片也是IC卡，但是是接触式的。本文中则只讨论非接触式IC卡。

### 非接触式IC卡
既然技术已经存在，那么就需要一定的标准来将其统一、规范化。
非接触式IC卡一般有三种国际规范：ISO/IEC 14443 Type A、ISO/IEC 14443 Type B、ISO/IEC 15693。三个规范都规定了工作在13.56Mhz下智能标签和读写器的空气接口及数据通信规范，但是类型不同。我们生活中更常见的是ISO/IEC 14443 Type A和ISO/IEC 14443 Type B规范的设备，15693则与公众关系不太密切，因此本文作为科普暂不讨论。

#### 14443-A
14443-A最为常见，其中最为知名的是前文提到的MIFARE系列，国内的复旦卡等早期均是模仿MIFARE系列开发的，MIFARE的解决方案最为流行，也是大家都兼容的方案。
>MIFARE是恩智浦半导体公司（NXP Semiconductors）拥有的一系列非接触式智能卡和近傍型卡技术的注册商标。
MIFARE包括一系列依循ISO/IEC 14443-A规格，利用无线射频识别（频率为13.56MHz）的多种非接触式智能卡专有解决方案。这项技术是最早是1994年由米克朗集团（Mikron Group）开发，在1998年转售给飞利浦电子公司（2006年更名为恩智浦半导体公司）。近年来MIFARE已经普遍在日常生活当中使用，如大众运输系统付费、商店小额消费、门禁安全系统、借书证等。
>
><small>*摘自：[zh.wikipedia.org/wiki/MIFARE](https://zh.wikipedia.org/wiki/MIFARE)*</small>

![](/images/posts/2019/09/jiagou.png)
上图为MIFARE卡片的架构，
>UID：唯一标识符（Unique Identifier）， RID：安全随机标识符（Random Security Identifier）
>
>- 卡片架构：卡片上面有一组唯一标识符、通信接口（包含天线及调制解调器）以及一个ASIC里面包含了通信逻辑电路、加密控制逻辑电路与数据存储区（ EEPROM），可以作为电子钱包或其它门禁、差勤考核、借书证等用途。
>  * 数据存储区块：可分16个区段（sector 0-15）， 每个区段由4个区块（block 0-3）组成，而每个区块都是独立的单元，每1个区块的容量有16Byte。而每个区段的最后一个区块则用来存放2组密钥（KeyA、KeyB），以及密钥对应各自的访问权限（Access bit）。
>  * 每张卡片第一区段的第一区块（sector 0，block 0）只能读取无法写入数据，称为制造商代码（Manufacturer Code）, 第1－4byte为UID。第5byte为比特计数检查码（bit count check)，其余的存放卡片制造商的数据。所以每张卡片实际能使用的只有15个区段，即便如此也可用于15个不同的应用。
>- 读写卡机架构：读卡器包含CPU、电源模块、读（写）模块、记忆模块、控制模块等，有些还有显示模块、定时模块等其他模块。
>- 工作流程：当卡片接近读写卡机进入通信天线的感应范围（约2.5公分至10公分）之后，读写卡机便会提供微量电力（约达2伏特之后）驱动卡片上的电路。此时卡、机各以曼彻斯特编码（MANCHESTER Encoding）及米勒编码（Miller encoding）加密通信内容后再以振幅偏移调制（Amplitude Shift Keying，ASK）透过调制解调器收发无线电波信号互相验证是否为正确卡片，如果验证结果正确读写卡机就会确认要访问的数据存储区块，并对该区块进行密码校验，在卡、 机三重认证无误之后，就可以透过加密进行实际工作通信。这个过程大约只需要0.1秒就可以完成。如果同时有多张卡片进入读写卡机感应范围，读写卡机会将卡 片编号并选定1张卡片进行验证直到完成所有卡片验证（称为防碰撞机制）或是离开感应范围为止。
>  * 卡 机三重认证步骤：1.卡片产生一个随机数RB发送到读卡器。2.读卡器会将接收到的随机数RB依公式加密编码后的TokenAB数值并发送回卡片。3.卡片接 收到TokenAB后，会把加密部分解译出来然后比对参数B、随机数RB。同时并依据收到的随机数RA，引用公式编码后产生TokenBA发送回读卡器。4. 读卡器接收到TokenBA后，又把加密过的部分解译，比较随机数RB，RA与TokenBA中解出之RB、RA是否相符，正确的就可以完成指令（扣款、打 开门锁或是登记其他事项）。
>
><small>*摘自：[zh.wikipedia.org/wiki/MIFARE](https://zh.wikipedia.org/wiki/MIFARE)*</small>

MIFARE系列最常用的就是各种1K卡，也就是存储容量为1Kbytes的卡。简单来说，1K卡将整张卡片的数据区域分割为16个扇区，4个区块，每个区块长度为32位，每一位都是0-F的16进制数，每2位为1Byte，所以每一块为16Bytes，总容量`16 * 4 * 16 = 1024Bytes = 1K`。每个扇区各自独立，正常情况下，0扇区0块：第1－4byte为UID，第5byte为比特计数检查码（bit count check)，其余的存放卡片制造商的数据，包括卡片类型等。整个0扇区一般无法被更改。剩下15个扇区中每个扇区只有三个块可用，每个扇区的最后一个块的结构为：12位KeyA+8位控制字+12位KeyB。控制字负责控制整个扇区的读写状态，KeyA和B用于开发者自行根据需要来控制使用不同Key的权限。一定程度上算是安全的，但是每个密钥均为固定，所以通过一定的暴力破解和逆向手段，也有可能获得卡片的全部密钥，安全性不足。（下图为数据区块示意图）（没看懂也没事，下文会详细分析的）
![](/images/posts/2019/09/blocks.png)

#### 14443-B
14443-B则用于安全性更高的产品，如二代身份证、电子护照等。事实上，针对14443-B的破解手段也非常罕见，因此我也难以展开细讲。

### MIFARE卡片的破解
刚介绍了一些原理什么的，我们就开始对其进行破解，是不是哪里不太对？其实这边介绍破解的技术和思路可以更容易地理解MIFARE卡片的原理。之前讲的都是理论概念，这里开始实际操作。

首先，针对MIFARE卡片的研究，我们可以使用由Jonathan Westhues在做硕士论文中研究Mifare Classic时设计、开发的一款开源硬件**Proxmark3**，可以用于RFID中嗅探、读取以及克隆等相关操作。这个名为Proxmark3的设备在某宝即可获得，售价几百元不等，一般学习的话选择最便宜的即可。一般卖家会给你提供这样的一个软件以便操作。
![](/images/posts/2019/09/pm3_easy_gui.png)
具体的操作参考卖家给出的教程即可，这里主要对技术问题进行分析。

#### 默认密码和PRNG
教程中一般会提到：使用默认密码扫描无法被破解的卡片可以用PRNG破解功能来进行下一步操作。那么默认密码是什么？
由于MIFARE的机制，导致卡片中每一个扇区都必须存在密码才能使用，因此需要存在约定俗称的几个普通密码，使用这些常见的密码可以方便在未激活时修改数据，必要时将其更改为更可靠的密码即可。默认密码中一般有：
- FFFFFFFFFFFF
- A0A1A2A3A4A5
- 000000000000
- (...)
其他还有很多，不同的地方定义不同，但是共同点都是非常简单，很容易猜测。如果卡片中存在这样的密码可以被扫描到，那么这张卡的安全性非常薄弱，克隆甚至修改都不成问题。
如果不存在默认密码，那么难道只能穷尽所有的可能，逐一尝试密码吗？事实上MIFARE卡片本身的机制也存在一定的问题，这个问题导致了darkside攻击的存在：PRNG破解。
卡片密钥破解的关键是让卡片发送加密数据，再通过算法解出密钥，所以需要欺骗卡片发出加密数据。我们考虑首先要把卡片中的密钥相关的数据骗出来，也就是让卡片发送出来一段加密的数据，我们通过这段加密的数据才能把密钥破解出来，如果卡片不发送加密的数据给我们，那就没法破解了。而第一次验证的时候卡片会发送明文的随机数给读卡器，然后验证读卡器发送加密数据给卡片，卡片验证失败就停止，不会发送任何数据了，不过，经过研究人员大量的测试后发现卡片算法中存在漏洞，当读卡器发出的密文中某8bit数据正确时，读卡器就会回复一个4bit的密文，而这个密文就包含了密钥的信息，再通过解密算法即可解出密钥。Linux下的mfcuk（MiFare Classic Universal toolKit）就是这样一个基于darkside原理攻击全加密卡的程序。GitHub：(nfc-tools/mfcuk)[https://github.com/nfc-tools/mfcuk]。因此，通过这个原理，就可以使用读卡器进行darkside攻击，也就是一般所说的PRNG破解。
关于PRNG的详细内容可以看以下资料：
>伪随机数生成器（pseudo random number generator，PRNG），又被称为确定性随机比特生成器（deterministic random bit generator，DRBG），[1]是一个生成数字序列的算法，其特性近似于随机数序列的特性。PRNG生成的序列并不是真随机，因此它完全由一个初始值决定，这个初始值被称为PRNG的随机种子（seed，但这个种子可能包含真随机数）。尽管接近于真随机的序列可以通过硬件随机数生成器生成，但伪随机数生成器因为其生成速度和可再现的优势，在实践中也很重要。
>PRNG是模拟（例如，蒙特卡洛方法）、电子游戏（例如过程生成）以及密码学等应用的核心。加密应用程序要求不能从以前的输出中预测输出，而且更复杂的、不具有简单PRNGs线性特性的算法是必要的。
>良好的统计特性，是PRNG的核心。通常，需要严格的数学分析来证明PRNG生成的序列足够接近真随机以满足预期用途。John von Neumann（约翰·冯·诺伊曼）警告不要把PRNG错误地解释为真随机数生成器。
>
>PRNG通过设定随机种子可以从任意初始值开始生成。同样的初始值总是生成同样的序列。PRNG的周期定义为：所有初始值的最大长度的无重复前缀序列。周期受状态数的限制，通常用比特位数表示。然而，每增加一个比特位，周期长度就可能增加一倍，所以构建周期足够长的PRNG对于许多实际应用程序来说是很容易的。
>如果PRNG的内部状态包含n位，那么它的周期不会超过2n，甚至可能非常短。对于大多数PRNG，周期长度的计算并不需要遍历整个周期。线性反馈移位寄存器（LFSR）的周期通常正好是2n−1。线性同余方法的周期可以通过因式分解进行计算。 尽管PRNG在达到周期之后会出现重复的结果，但重复序列的出现并不意味着到达了一个周期，因为它的内部状态可能比输出要大很多。对于输出为1位的PRNGs，这一点尤其明显。
>
><small>*摘自：[zh.wikipedia.org/wiki/伪随机数生成器](https://zh.wikipedia.org/wiki/伪随机数生成器)*</small>

#### nested authentication 攻击（大家常说的验证漏洞攻击）
首先我们需要了解卡片本身的验证逻辑：
第一次验证时，读卡器首先验证0扇区的密码，卡片给读卡器发送一个随机数n1（明文），然后读卡器通过跟密码相关的加密算法加密n1，同时自己产生一个密文随机数n2，发送给卡片。卡片用自己的密码解密之后，如果解密出来的就是自己之前发送的n1，则认为正确，然后通过自己的密码相关的算法加密读卡器的随机数n2成为密文n3，发送给读卡器。读卡器解密之后，如果跟自己之前发送的随机数n2相同，则认为验证通过，之后所有的数据都通过此算法加密传输。
![](/images/posts/2019/09/nested.png)
首先记住这里面只有第一次的n1是明文，之后都是密文，而且n1是卡片发送的，也就是验证过程中，卡片是主动先发随机数的。我们破解的时候，读卡器中肯定没有密码（如果有就不用破解了），那么卡片发送一个n1给读卡器之后，读卡器用错误的密码加密之后发送给卡片，卡片肯定解密错误，然后验证中断，这个过程中，我们只看到卡片发送的明文随机数，卡片根本没有把自己保存的密码相关的信息发送出来，那怎么破解呢？
所以，要已知一个扇区的密码，第一次验证的时候，使用这个扇区验证成功之后，后面所有的数据交互都是密文，读其他扇区数据的时候，也需要验证，也是卡片首先发送随机数n1，但是这里的n1是加密的数据。既然每个扇区的密码是独立的，那么现在的加密实际上就是通过卡片被读取的，相对于第一个读取的扇区的“其他扇区”的密码相关的算法加密的n1，这个数据中就包含了这个扇区的密码信息，所以我们才能够通过算法漏洞继续分析出扇区的密码是什么。
这也是为什么nested authentication攻击必须要知道某一个扇区的密码，然后才能破解其他扇区的密码。

#### 嗅探
以上两个破解方式组合就可以解决大部分的M1卡片了，但是可能出现例外，所以我们还有一种方法是嗅探攻击。



参考资料：
- [RFID破解三两事 - FreeBuf互联网安全新媒体平台](https://www.freebuf.com/articles/wireless/8792.html)
- [详谈Mifare Classic 1K卡 - 知乎](https://zhuanlan.zhihu.com/p/67532665)
- [维基百科](https://zh.wikipedia.org)
